{"version":3,"file":"component---src-pages-blog-performance-tracing-in-chrome-and-edge-js-bb41fd57f74e748da0e4.js","mappings":"4MA4FA,UAnFmB,KACjB,MAAMA,GAAOC,EAAAA,EAAAA,gBAAe,cAW5B,IAAIC,EAAkB,gIACtB,OACA,gBAAC,IAAM,CAACC,UAAU,4DAChB,gBAAC,IAAG,CAACC,MAAM,mDAAmDC,YAAaH,IAC3E,uBAAKI,UAAWC,EAAAA,IACZ,0BAAI,6BACJ,uBAAKD,UAAWC,EAAAA,IAAyBL,GACzC,uBAAKI,UAAWC,EAAAA,IAAiB,icAIjC,uBAAKD,UAAWC,EAAAA,IACd,gBAAC,IAAG,CAACC,MAAO,IAAIR,EAAKS,OAAOC,gBAAgBF,OAAQG,QAAQ,WAE9D,uBAAKL,UAAWC,EAAAA,GAAuB,sCACvC,uBAAKD,UAAWC,EAAAA,IAAiB,yJACD,qBAAGK,KAAK,mFAAkF,mCAAmC,6DAE7J,uBAAKN,UAAWC,EAAAA,IAAiB,grBAKjC,qBAAGK,KAAK,8FAA6F,eAAe,iNAGpH,uBAAKN,UAAWC,EAAAA,GAAuB,+CACvC,uBAAKD,UAAWC,EAAAA,IAAiB,4iBAKjC,uBAAKD,UAAWC,EAAAA,IAAiB,uTAEO,qBAAGK,KAAK,gFAA+E,cAAc,iiBAK7I,qBAAGA,KAAK,2HAA0H,iBAAiB,ihBAMnJ,uBAAKN,UAAWC,EAAAA,IAAiB,icAKjC,uBAAKD,UAAWC,EAAAA,IAAiB,ylBAKjC,uBAAKD,UAAWC,EAAAA,GAAuB,mBAAqB,wJAE5D,0BACA,0BAAI,6IAEJ,uBAAKD,UAAWC,EAAAA,GAAuB,4DACvC,uBAAKD,UAAWC,EAAAA,GAAuB,cACvC,uBAAKD,UAAWC,EAAAA,IAAiB,4RAM9B,C","sources":["webpack://gatsby-starter-default/./src/pages/blog/performance-tracing-in-chrome-and-edge.js"],"sourcesContent":["import React from \"react\"\r\nimport { useStaticQuery, graphql } from \"gatsby\"\r\n\r\nimport Layout from \"../../components/layout\"\r\nimport SEO from \"../../components/seo\"\r\nimport * as styles from \"./blog.module.css\"\r\n\r\nimport Img from \"gatsby-image\"\r\n\r\nconst SecondPage = () => {\r\n  const data = useStaticQuery(graphql`\r\n  {\r\n      splash: file(relativePath: { eq: \"tracing/tracing-splash.png\" }) {\r\n        childImageSharp {\r\n          fluid(maxWidth: 3000, quality: 100) {\r\n            ...GatsbyImageSharpFluid\r\n          }\r\n        }\r\n      }\r\n  }\r\n  `);\r\n  let blogDescription = \"The tracing tab is a powerful tool that can be harnessed by web developers looking to streamline their websites and web-apps.\"\r\n  return (\r\n  <Layout pageTitle=\"Rendering Performance Tracing in Chromium-based Browsers\">\r\n    <SEO title=\"Rendering Performance Tracing in Chrome and Edge\" description={blogDescription}/>\r\n    <div className={styles.childrenContainer}>\r\n        <h1>[chrome | edge]://tracing</h1>\r\n        <div className={styles.blogDescription}>{blogDescription}</div>\r\n        <div className={styles.blogText}>In this article, I explore what the Chromium renderer process is doing during a scroll, as an exercise for\r\n        learning how browser tracing works. Think of the\r\n        ://tracing tab as Dev Tools performance but on heavy steroids. For many web developers, dev tools is adequate in pointing out bottlenecks in\r\n        scripts, page loads, networking and rendering. However, if one needs more information than what devtools provides, then tracing can definitely help.</div>\r\n        <div className={styles.blogImage}>\r\n          <Img fluid={{...data.splash.childImageSharp.fluid}} loading=\"eager\"></Img>\r\n        </div>\r\n        <div className={styles.blogSubheading}>Chromium Multiprocess Architecture</div>\r\n        <div className={styles.blogText}>A browser is a vastly complicated piece of software, and one would require an entire textbook to explain how it works\r\n        in detail. However, knowing the <a href=\"https://www.chromium.org/developers/design-documents/multi-process-architecture\">high level process architecture</a>\r\n        &nbsp;will help us in understanding what we see in our traces.</div>\r\n        <div className={styles.blogText}> In order to keep the browser reliable and secure, Chromium employs a multi-process architecture. There's one browser\r\n        process, a renderer process for each tab (and cross domain iframes), and one gpu process. The browser process is the \"main\" process, responsible for\r\n        running the ui and managing tabs and plugins. This includes processing user input and delegating it to the right tab. The renderer process is where\r\n        a lot of the magic happens. It houses Blink, the Chromium rendering engine, responsible for executing the document lifecycle - a process which converts\r\n        HTML and CSS to data structures that can be converted into bitmaps and subsequently shown on screen. The role of the&nbsp;\r\n        <a href=\"https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome\">GPU process</a> is to provide\r\n        the renderer, which is sandboxed, access to OS specific 3D APIs. The renderer process issues commands via the Command Buffer to communicate with the\r\n        GPU process, which can call on GL or D3D.</div>\r\n        <div className={styles.blogSubheading}>Renderer Process and the Document Lifecycle</div>\r\n        <div className={styles.blogText}>The renderer is the primary process responsible for producing output. It is a multithreaded process, with two important\r\n        threads - main thread and compositor thread. The main thread houses Blink, the Chrome (and now Edge) rendering engine. Blink executes V8 compiled JavaScript, \r\n        such as invoking callbacks and dispatching events, and runs the document lifecycle; a process which involves computing style, layout, compositing, and painting outputs.\r\n        In addition to the aforementioned, Blink also handles input events if they are routed to the main thread.\r\n        </div>\r\n        <div className={styles.blogText}> A bulk of the conversion from HTML/CSS code to data structures that the browser can use to generate a bitmap happens \r\n        during the document lifecycle. The first step is building the Document Object Model (DOM) tree. HTML is parsed, and Blink converts it into a DOM tree \r\n        with nodes being elements. An element's <a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM\">Shadow DOM</a> is parsed as\r\n        its own tree; therefore, the DOM tree is thought of as a \"composed tree\", or a tree of trees. A composed tree can be thought of as one big tree; however, the\r\n        distinction here is that a shadow host can not see a shadow root, but the opposite is possible. Once the DOM tree is built, styles are resolved for each\r\n        node. Here, the style engine is responsible for aggregating all rules from stylesheets and default rules, resolving conflicts, and computing the final style\r\n        of the element. These styles are stored in a big map called&nbsp;\r\n        <a href=\"https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/style/computed_style.h;l=199\">ComputedStyle</a>. After styles\r\n        are resolved, the DOM tree is converted into a layout tree. In this process, the visual geometry of all the objects is determined. Upon the construction of our\r\n        layout tree, the Compositing lifecycle begins. Compositing is the process of composing a layer tree from the layout tree. Rather than paint the entire layout\r\n        tree in one go, Blink splits the page into layers. The main advantage here is that the browser can update only the layers it needs to when parts of the page\r\n        change, rather than the everything.\r\n        </div>\r\n        <div className={styles.blogText}>\r\n        Finally, it's painting time. Paint issues a series of \"paint operations\" to a DisplayItem list. A paint op would be something like \"draw a rectangle\r\n        at these coordinates, in this color\". It is important to note that painting is done in a stacking order, rather than DOM order. This means that items with the\r\n        lowest z-index are painted first. Additionally, it is possible that different parts within an element can be painted at different times. \r\n        </div>\r\n        <div className={styles.blogText}>Everything mentioned above happens on the main thread of the renderer. Painted output is committed to the compositor\r\n        thread, where it is rasterized. Rasterization invloves splitting the layer into tiles and converting the tiles painted output into a bitmap. Once a \r\n        tile is rasterized, the compositor thread creates a draw quad for it; which is a command to draw the tile at its particular location. These quads then\r\n        get packaged into a \"Compositor Frame\", which is the output of the renderer process, and sent to the browser process to be presented to the screen; with the help\r\n        of the GPU process.</div>\r\n        <div className={styles.blogSubheading}>The Tracing Tab</div>\r\n        Now that you have some background on what your browser does, we can move on to tracing. Here are step by step instructions on how to collect a trace.\r\n        <ol>\r\n        <li>If using Google Chrome, the tracing tab can be reached by navigating to chrome://tracing. On Microsoft Edge it would be edge://tracing. </li>\r\n        </ol>\r\n        <div className={styles.blogSubheading}>Using //tracing to Understand What Your Website is Doing</div>\r\n        <div className={styles.blogSubheading}>References</div>\r\n        <div className={styles.blogText}>\r\n        https://www.chromium.org/developers/design-documents/multi-process-architecture\r\n        https://docs.google.com/presentation/d/1i1Brb5FTmjStDpnUeKBphKZOJVjZzpM_rv5Wb3TMMtU/edit#slide=id.g28a69a47b7_0_18\r\n        https://docs.google.com/document/d/1aitSOucL0VHZa9Z2vbRJSyAIsAz24kX8LFByQ5xQnUg/edit\r\n        </div>\r\n    </div>\r\n  </Layout>)\r\n}\r\n\r\nexport default SecondPage\r\n"],"names":["data","useStaticQuery","blogDescription","pageTitle","title","description","className","styles","fluid","splash","childImageSharp","loading","href"],"sourceRoot":""}